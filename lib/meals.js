import fs from 'node:fs';

import sql from 'better-sqlite3';
import slugify from 'slugify';
import xss from 'xss';

const db=sql('meals.db');

export async function getMeals(){
   await new Promise((resolve)=>setTimeout(resolve,5000));//to delay the output(data fetch) for 5secs to show loading 
   /**When page load for 1st time or reload it takes time to load but once loaded when we chage pages and come back to same page,it won't take time to load data 
    * because next js cached these data.So it loads data from cache.there is an issue in Next js, so the cache works some times and sometimes not while changing route frote from community to browse meals.  */
  // throw new Error("An error occured"); // to simulate error,to add feature to handle error in page
   return db.prepare('SELECT * FROM meals').all();//.run() used while inserting data,to fet single row .get() can use
   /**sqllite code doesn't produce promise but as MealPage is a server side function ,so it can be converted to async function. 
    * and if we have some code that uses promise then we can use await .
    * we are making getMeals function as async because it will return a promise because sqllite code don't.
   */
}

export function getMeal(slug){
   /** if we will do like this (db.prepare('SELECT * FROM meals where slug= ' + slug)),then it would be insecure,it opens up to sql injection.
    * So doing like below,? as a placeholder and add placeholder value to get.Under the hood better-sqlite protects from sql injection attacks
   */
   return db.prepare('SELECT * FROM meals where slug= ?').get(slug);
}
export async function saveMeal(meal){
 //meal object(data) we are getting from user input doesn't contain slug ,which is requied for database entry(slug is a meal table unique field).So we will create it with title
 meal.slug=slugify(meal.title,{lower:true});
 //XSS package(npm install xss) will help us protect against cross-site scripting attacks.
 /**we're storing user-generated content and then outputting these instructions that are generated by the user as HTML(dangerouslySetInnerHTML={{__html:meal.instructions}}),
  * in that "meal" detail page,So we are vulnerable to cross-site scripting attacks and that's why we should protect against them 
  * That's why we should sanitize the content that's sent by the user,which is exactly what we can do with help of this xss package. */
   meal.instructions=xss(meal.instructions);
   //create standard image filename,not the user's name
   /**split filename with dot (as extension is after dot),and then pop(),to get last split item */
   const extension=meal.image.name.split('.').pop();
   const fileName=`${meal.slug}.${extension}`;
   /**Write a file to a public folder with filesystem(fs) api provided by node js(fs from 'node:fs') 
    *  it's a stream allow us to write data to a cretain file,it has a path where file will be stored with filename 
   */
   const stream=fs.createWriteStream(`public/images/${fileName}`);
   //we can write data to that path by calling write method 
   /**When you're dealing with large files or streams, breaking the data into smaller, manageable pieces or "chunks" can help in efficient processing and handling,
    *  especially in scenarios where the entire dataset might not fit into memory at once.In our code, each call to write() represents a portion of data being written to the file.
    * simple Node.js example[const writeStream = fs.createWriteStream('output.txt');
    * // Writing a chunk of data to the stream
    * writeStream.write('Hello, ');
    * // Writing another chunk of data to the stream
    * writeStream.write('world!');
    * // Closing the stream
    * writeStream.end();
] */
/**arrayBuffer() gives a promise ,so we must await hete and make function to async */
   const bufferedImage=await meal.image.arrayBuffer();
   /**write () wants regular buffer(chuck) and we have arrayBuffer,so we will make it like below ,2nd argument of write() is
    * a function that will execute once it's done writing.which will be null if everything is correct but if not then then it will execute this error function
    */
   stream.write(Buffer.from(bufferedImage),(error)=>{
      if(error){
         throw new Error('Saving image failed');
      }
   });
   //now we will override image object with the file stored path.here we will not include public in path name as he content of the public folder will be served on the root level
   meal.image=`/images/${fileName}`;
   //Now we will store data to database
   /**iF WE WILL INSERT data ON Values fields directly then it would be vulnerable to SQL injection attacks.
    * Instead, you should use those placeholders one for every field And then later just pass an object to the run function,
    * which we will call on this prepared statement and better-sqlite package we're using to execute this command here,will then look at those property names
    * in that object we're passing to it to extract the values stored under those property names and it will then use those values to store them in those fields.*/
   db.prepare(`INSERT INTO meals
      (title ,summary,instructions, creator, creator_email, image ,slug) 
      VALUES(@title ,@summary,@instructions, @creator,@creator_email, @image ,@slug)`).run(meal);
}