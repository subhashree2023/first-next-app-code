import sql from 'better-sqlite3';
import slugify from 'slugify';
import xss from 'xss';

const db=sql('meals.db');

export async function getMeals(){
   await new Promise((resolve)=>setTimeout(resolve,5000));//to delay the output(data fetch) for 5secs to show loading 
   /**When page load for 1st time or reload it takes time to load but once loaded when we chage pages and come back to same page,it won't take time to load data 
    * because next js cached these data.So it loads data from cache.there is an issue in Next js, so the cache works some times and sometimes not while changing route frote from community to browse meals.  */
  // throw new Error("An error occured"); // to simulate error,to add feature to handle error in page
   return db.prepare('SELECT * FROM meals').all();//.run() used while inserting data,to fet single row .get() can use
   /**sqllite code doesn't produce promise but as MealPage is a server side function ,so it can be converted to async function. 
    * and if we have some code that uses promise then we can use await .
    * we are making getMeals function as async because it will return a promise because sqllite code don't.
   */
}

export function getMeal(slug){
   /** if we will do like this (db.prepare('SELECT * FROM meals where slug= ' + slug)),then it would be insecure,it opens up to sql injection.
    * So doing like below,? as a placeholder and add placeholder value to get.Under the hood better-sqlite protects from sql injection attacks
   */
   return db.prepare('SELECT * FROM meals where slug= ?').get(slug);
}
export function saveMeal(meal){
 //meal object(data) we are getting from user input doesn't contain slug ,which is requied for database entry(slug is a meal table unique field).So we will create it with title
 meal.slug=slugify(meal.title,{lower:true});
 //XSS package(npm install xss) will help us protect against cross-site scripting attacks.
 /**we're storing user-generated content and then outputting these instructions that are generated by the user as HTML(dangerouslySetInnerHTML={{__html:meal.instructions}}),
  * in that "meal" detail page,So we are vulnerable to cross-site scripting attacks and that's why we should protect against them 
  * That's why we should sanitize the content that's sent by the user,which is exactly what we can do with help of this xss package. */
   meal.instructions=xss(meal.instructions);
   //create standard image filename,not the user's name
   /**split filename with dot (as extension is after dot),and then pop(),to get last split item */
   const extension=meal.image.name.split('.').pop();
   const fileName=`${meal.slug}.${extension}`;
}